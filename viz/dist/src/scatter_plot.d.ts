import * as THREE from 'three';
import { LabelRenderParams } from './render';
import { Styles } from './styles';
import { Optional, Point3D, InteractionMode } from './types';
import { ScatterPlotVisualizer } from './scatter_plot_visualizer';
export interface OrbitControlParams {
    mouseRotateSpeed: number;
    autoRotateSpeed: number;
    zoomSpeed: number;
}
export declare type OnCameraMoveListener = (cameraPosition: THREE.Vector3, cameraTarget: THREE.Vector3) => void;
export interface CameraDef {
    orthographic: boolean;
    position: Point3D;
    target: Point3D;
    zoom: number;
}
export declare type CameraParams = Partial<Pick<CameraDef, 'position' | 'target' | 'zoom'>>;
export interface ScatterPlotParams {
    camera?: CameraParams;
    onClick?: (point: number | null) => void;
    onHover?: (point: number | null) => void;
    onSelect?: (points: number[]) => void;
    selectEnabled?: boolean;
    styles: Styles;
    orbitControlParams?: Optional<OrbitControlParams>;
}
export declare class ScatterPlot {
    private container;
    private styles;
    private clickCallback;
    private hoverCallback;
    private selectCallback;
    private selectEnabled;
    private visualizers;
    private onCameraMoveListeners;
    private height;
    private width;
    private dimensions;
    private interactionMode;
    private renderer;
    private scene;
    private pickingTexture;
    private light;
    private camera;
    private orbitAnimationOnNextCameraCreation;
    private orbitCameraControls;
    private orbitAnimationId;
    private worldSpacePointPositions;
    private pointColors;
    private pointScaleFactors;
    private labels?;
    private polylineColors;
    private polylineOpacities;
    private polylineWidths;
    private selecting;
    private nearestPoint;
    private mouseIsDown;
    private isDragSequence;
    private rectangleSelector;
    private readonly orbitControlParams;
    constructor(containerElement: HTMLElement, params: ScatterPlotParams);
    private setParameters;
    private addInteractionListeners;
    private addCameraControlsEventListeners;
    private makeOrbitControls;
    private makeCamera;
    private makeCamera3D;
    private makeCamera2D;
    private makeDefaultCameraDef;
    recreateCamera(cameraDef: CameraDef): void;
    setInteractionMode(interactionMode: InteractionMode): void;
    private onClick;
    private onMouseDown;
    private onMouseUp;
    private lastHovered;
    private onMouseMove;
    private onKeyDown;
    private onKeyUp;
    private getPointIndicesFromBoundingBox;
    private getPointIndicesFromBoundingBoxPickingTexture;
    private selectBoundingBox;
    private setNearestPointToMouse;
    private computeLayoutValues;
    private sceneIs3D;
    private remove3dAxesFromScene;
    private add3dAxes;
    setDimensions(dimensions: number): void;
    getCameraPosition(): Point3D;
    getCameraTarget(): Point3D;
    setCameraPositionAndTarget(position: Point3D, target: Point3D): void;
    startOrbitAnimation(): void;
    orbitIsAnimating(): boolean;
    private updateOrbitAnimation;
    stopOrbitAnimation(): void;
    setActiveVisualizers(visualizers: ScatterPlotVisualizer[]): void;
    disposeAllVisualizers(): void;
    setPointPositions(worldSpacePointPositions: Float32Array): void;
    render(): void;
    setPointColors(colors: Float32Array): void;
    setPointScaleFactors(scaleFactors: Float32Array): void;
    setLabels(labels: LabelRenderParams): void;
    setPolylineColors(colors: {
        [polylineIndex: number]: Float32Array;
    }): void;
    setPolylineOpacities(opacities: Float32Array): void;
    setPolylineWidths(widths: Float32Array): void;
    resetZoom(): void;
    setDayNightMode(isNight: boolean): void;
    resize(render?: boolean): void;
    onCameraMove(listener: OnCameraMoveListener): void;
    clickOnPoint(pointIndex: number): void;
}
